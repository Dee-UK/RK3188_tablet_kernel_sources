53c53,57
< #if defined(CONFIG_CT36X_TS)
---
> #if defined(CONFIG_DP_ANX6345)
> #include<linux/anx6345.h>
> #endif
> 
> #if defined(CONFIG_CT36X_TS)||(CONFIG_TOUCHSCREEN_CT36X)
77a82,85
> #ifdef CONFIG_CW2015_BATTERY
> #include <linux/power/cw2015_battery.h>
> #endif
> 
88d95
< 
99d105
< 
100a107
> #if defined (CONFIG_PIPO_M6PRO)
108a116,152
> 		.desc	= "back",
> 		.code	= KEY_BACK,
> 		.gpio = INVALID_GPIO,
> 		.adc_value	= 355,
> 		.active_low = PRESS_LEV_LOW,
> 	},
> 	{
> 		.desc	= "vol-",
> 		.code	= KEY_VOLUMEDOWN,  //KEY_VOLUMEDOWN,
> 		.gpio = INVALID_GPIO,
> 		.adc_value	= 145,
> 		.active_low = PRESS_LEV_LOW,
> 	},
> 	{
> 		.desc	= "vol+",
> 		.code	= KEY_VOLUMEUP,
> 		.gpio = INVALID_GPIO,
> 		.adc_value	= 1,
> 		.active_low = PRESS_LEV_LOW,
> 	},
> #else
> 	{
> 		.desc	= "play",
> 		.code	= KEY_POWER,
> 		.gpio	= RK30_PIN0_PA4, 
> 		.active_low = PRESS_LEV_LOW,
> 		.wakeup	= 1,
> 	},
> 		{
> 		.desc	= "menu",
> 		.code	= EV_MENU,
> 		.adc_value	= 159,
> 		.gpio = INVALID_GPIO,
> 		.active_low = PRESS_LEV_LOW,
> 		.code_long_press = KEY_VOLUMEDOWN,
> 	},
> 	{
113a158
> 		.code_long_press = KEY_VOLUMEUP,
114a160
> #endif
138,148c184
< #ifdef CONFIG_TOUCHSCREEN_VTL_CT36X
< #include "../../../drivers/input/touchscreen/vtl_ts/vtl_ts.h" //结构体 config_info 的声明
< struct ts_config_info vtl_ts_config_info={
< 	.screen_max_x =1920, //x轴分辨率
< 	.screen_max_y=1200,  //y轴分辨率
< 	.irq_gpio_number=RK30_PIN1_PB7, //中断GPIO管脚
< 	.rst_gpio_number=RK30_PIN0_PB6, //复位GPIO管脚
< 	};
< 	#endif
< 
< #if defined(CONFIG_CT36X_TS)
---
> #if defined(CONFIG_CT36X_TS) || (CONFIG_TOUCHSCREEN_CT36X)
151,152c187,193
< #define TOUCH_MAX_X		1920//1280
< #define TOUCH_MAX_y		1200//800
---
> #if defined (CONFIG_PIPO_M6PRO)
> #define TOUCH_MAX_X		1024
> #define TOUCH_MAX_y		768
> #else
> #define TOUCH_MAX_X		1920
> #define TOUCH_MAX_y		1200
> #endif
180a222,224
> #if defined (CONFIG_PIPO_M6PRO)
> #define PWM_EFFECT_VALUE  0
> #else
181a226
> #endif
188a234,239
> 
> #define HUB_RST
> #ifdef  HUB_RST
> #define HUB_RST_PIN RK30_PIN0_PC2
> #endif
> 
195c246
< 	ret = gpio_request(BL_EN_PIN, NULL);
---
> 	ret = gpio_request(BL_EN_PIN, NULL); //"bl_en"
201a253,260
> #ifdef  HUB_RST
> 	ret = gpio_request(HUB_RST_PIN, NULL);
> 	if (ret != 0) {
> 		gpio_free(HUB_RST_PIN);
> 	}
> 	gpio_direction_output(HUB_RST_PIN, 0);
> 	gpio_set_value(HUB_RST_PIN, GPIO_HIGH);
> #endif
211a271
> 	gpio_direction_output(BL_EN_PIN, !BL_EN_VALUE);
216c276
< 	gpio_request(pwm_gpio, NULL);
---
> 	gpio_request(pwm_gpio, "bl_pwm"); // NULL
223c283
< 	int ret = 0, pwm_gpio;
---
> 	int ret, pwm_gpio;
225,226c285,287
< 	pwm_gpio = iomux_mode_to_gpio(PWM_MODE);
< 	if (gpio_request(pwm_gpio, NULL)) {
---
> 	pwm_gpio = iomux_mode_to_gpio(PWM_MODE);//PWM_MODE = PWM3
> 	ret = gpio_request(pwm_gpio, NULL);
> 	if (ret) {
228,230c289,291
< 		return -1;
< 	}
< 	gpio_direction_output(pwm_gpio, GPIO_LOW);
---
> 	} else
> 	{
> 		gpio_direction_output(pwm_gpio, GPIO_LOW);
232,233c293,295
< 	gpio_direction_output(BL_EN_PIN, 0);
< 	gpio_set_value(BL_EN_PIN, !BL_EN_VALUE);
---
> 		gpio_direction_output(BL_EN_PIN, 0);
> 		gpio_direction_output(BL_EN_PIN, !BL_EN_VALUE);//d33
> 		gpio_set_value(BL_EN_PIN, !BL_EN_VALUE);
234a297
> 	}
253,254c316,317
<         .min_brightness = 10,
<         .max_brightness = 120,
---
>         .min_brightness = 0,//10
>         .max_brightness = 255,
256c319
< 	.pre_div = 40 * 1000,  // pwm output clk: 30k;
---
> 	.pre_div = 30 * 1000,  // pwm output clk: 30k;
306,307c369,376
< 	.orientation = {0, -1, 0, -1, 0, 0, 0, 0, -1},
< };
---
> #if defined (CONFIG_PIPO_M7PRO)
> 	.orientation = {-1, 0, 0, 0, 1, 0, 0, 0, -1},//M7PRO
> #endif
> #if defined (CONFIG_PIPO_M6PRO) 
> 	.orientation = {0, 1, 0, 1, 0, 0, 0, 0, -1}, //M6PRO
> #endif
> #if !defined (CONFIG_PIPO_M6PRO) && !defined (CONFIG_PIPO_M7PRO)
> 	.orientation = {0, 1, 0, 1, 0, 0, 0, 0, -1,},
308a378,380
> };
> 
> #endif //(CONFIG_GS_LIS3DH)
312a385
> 	/*
315,316c388,419
<        .poll_delay_ms = 30,
<        .layout = 5,	//8963只需要改这个值就行了。矩阵需要固定。不要修改矩阵
---
>        .poll_delay_ms = 0,
>        .m_layout = 
>        {
> 		{	
> 			{-1, 0, 0},
> 			{0, 1, 0},
> 			{0, 0, -1},
> 		},
> 
> 		{
> 			{1, 0, 0},
> 			{0, 1, 0},
> 			{0, 0, 1},
> 		},
> 
> 		{
> 			{0, -1, 0},
> 			{-1, 0, 0},
> 			{0, 0, -1},
> 		},
> 
> 		{
> 			{1, 0, 0},
> 			{0, 1, 0},
> 			{0, 0, 1},
> 		},
>        }
> */
>        .type = SENSOR_TYPE_COMPASS,
>        .irq_enable = 1,
>        //.poll_delay_ms = 0,
>        .layout = 8,	//8963禄猫陋啪芒啪枚碌鸥隆拢鸥贸猫陋鹿露拧隆拢虏禄陋啪鸥贸
356,363d458
< /*#ifdef CONFIG_LS_CM3232
< static struct sensor_platform_data cm3232_info = {
< 	.type = SENSOR_TYPE_LIGHT,
< 	.irq_enable = 0,
< 	.poll_delay_ms = 500,
< };
< #endif*/
< 
442a538,540
> #if defined (CONFIG_PIPO_M6PRO)
> #define L3G4200D_INT_PIN  RK30_PIN1_PA7
> #else
443a542
> #endif
454c553,562
< 	.orientation = {1, 0, 0 , 0 , -1, 0, 0, 0, -1},
---
> #if defined(CONFIG_PIPO_M7PRO)
> 	.orientation = {-1, 0, 0 , 0 , 1, 0, 0, 0, -1},
> //	.orientation = {1, 0, 0 , 0 , -1, 0, 0, 0, -1},
> #endif 
> #if defined (CONFIG_PIPO_M6PRO)
> 	.orientation = {0, 1, 0, 1, 0, 0 , 0, 0, 1},
> #endif
> #if !defined (CONFIG_PIPO_M6PRO) && !defined (CONFIG_PIPO_M7PRO)
> 	.orientation = {0, -1, 0 , -1 , 0, 0, 0, 0, -1},
> #endif
494c602
< 		.enable_pin = RK30_PIN0_PB0,//RK30_PIN3_PD4,
---
> 		.enable_pin = RK30_PIN3_PD4,//RK30_PIN3_PD4,
518c626
< #define LCD_CS_PIN         INVALID_GPIO
---
> #define LCD_CS_PIN         INVALID_GPIO//RK30_PIN1_PB6//(u30gt2)
523c631
< #define LCD_EN_PIN         RK30_PIN1_PB2//RK30_PIN0_PB1
---
> #define LCD_EN_PIN         RK30_PIN0_PB0//RK30_PIN0_PB1
526a635,638
> 
> #if defined (CONFIG_PIPO_M6PRO)
> #define LCD_EN_VALUE       GPIO_HIGH
> #else
527a640,649
> #endif
> 
> #define LCD_PWR_PIN         RK30_PIN1_PB5
> #define LCD_PWR_VALUE       GPIO_HIGH
> 
> #define LCD_CS_PIN_1         RK30_PIN3_PD4
> #define LCD_CS_VALUE_1       GPIO_HIGH
> 
> #define LCD_PWR_PIN_1         RK30_PIN0_PA7
> #define LCD_PWR_VALUE_1       GPIO_HIGH
547a670,686
> 	if(LCD_CS_PIN_1 !=INVALID_GPIO)
> 	{
> 		ret = gpio_request(LCD_CS_PIN_1, NULL);
> 		if (ret != 0)
> 		{
> 			gpio_free(LCD_CS_PIN_1);
> 			printk(KERN_ERR "request lcd cs pin fail!\n");
> 			return -1;
> 		}
> 		else
> 		{
> 			gpio_direction_output(LCD_CS_PIN_1, LCD_CS_VALUE_1);
> 		}
> 	}
> 
> 
> 
561a701,732
> 	if(LCD_PWR_PIN !=INVALID_GPIO)
> 	{
> 		ret = gpio_request(LCD_PWR_PIN, NULL);
> 		if (ret != 0)
> 		{
> 			gpio_free(LCD_PWR_PIN);
> 			printk(KERN_ERR "request lcd en pin fail!\n");
> 			return -1;
> 		}
> 		else
> 		{
> 			gpio_direction_output(LCD_PWR_PIN, LCD_PWR_VALUE);
> 		}
> 	}
> 	if(LCD_PWR_PIN_1 !=INVALID_GPIO)
> 	{
> 		ret = gpio_request(LCD_PWR_PIN_1, NULL);
> 		if (ret != 0)
> 		{
> 			gpio_free(LCD_PWR_PIN_1);
> 			printk(KERN_ERR "request lcd en pin fail!\n");
> 			return -1;
> 		}
> 		else
> 		{
> 			gpio_direction_output(LCD_PWR_PIN_1, LCD_PWR_VALUE_1);
> 		}
> 	}
> 
> 
> 
> 
569a741,745
> 	if(LCD_CS_PIN_1 !=INVALID_GPIO)
> 	{
> 		gpio_set_value(LCD_CS_PIN_1, !LCD_CS_VALUE_1);
> 	}
> 
573a750,758
> 	if(LCD_PWR_PIN !=INVALID_GPIO)
> 	{
> 		gpio_direction_output(LCD_PWR_PIN, !LCD_PWR_VALUE);
> 	}
> 	if(LCD_PWR_PIN_1 !=INVALID_GPIO)
> 	{
> 		gpio_direction_output(LCD_PWR_PIN_1, !LCD_PWR_VALUE_1);
> 	}
> 
581a767,771
> 	if(LCD_CS_PIN_1 !=INVALID_GPIO)
> 	{
> 		gpio_set_value(LCD_CS_PIN_1, LCD_CS_VALUE_1);
> 	}
> 
585a776,784
> 	if(LCD_PWR_PIN !=INVALID_GPIO)
> 	{
> 		gpio_direction_output(LCD_PWR_PIN, LCD_PWR_VALUE);
> 	}
> 	if(LCD_PWR_PIN_1 !=INVALID_GPIO)
> 	{
> 		gpio_direction_output(LCD_PWR_PIN_1, LCD_PWR_VALUE_1);
> 	}
> 
590a790,796
> #if defined (CONFIG_PIPO_M6PRO)
> 	.prop	   = PRMRY,		//primary display device
> 	.io_init   = rk_fb_io_init,
> 	.io_disable = rk_fb_io_disable,
> 	.io_enable = rk_fb_io_enable,
> 	.set_screen_info = set_lcd_info,
> #else
594c800
< 
---
> #endif
599a806,810
> #if defined (CONFIG_PIPO_M6PRO)
> 	.prop           = EXTEND,       //extend display device
>        .lcd_info  = NULL,
>        .set_screen_info = hdmi_init_lcdc,
> #else
605c816
< 	
---
> #endif	
608a820
> 
781a994
> 
782a996,998
> #if defined (CONFIG_PIPO_M6PRO)
> #define ION_RESERVE_SIZE        (80 * SZ_1M)
> #else
783a1000,1002
> #endif
> #define ION_RESERVE_SIZE_120M   (120 * SZ_1M)
> 
791c1010
< 			.size = ION_RESERVE_SIZE,
---
> 			//.size = ION_RESERVE_SIZE,
804a1024,1086
> #ifdef CONFIG_DP_ANX6345
> 
> 	#define DVDD33_EN_PIN 		RK30_PIN0_PB0
> 	#define DVDD33_EN_VALUE 	GPIO_LOW
> 	
> 	#define DVDD18_EN_PIN 		RK30_PIN3_PD4//RK30_PIN3_PD4//RK30_PIN1_PB6//RK30_PIN4_PC7
> 	#define DVDD18_EN_VALUE 	GPIO_HIGH
> 
> 	#define EDP_RST_PIN 		RK30_PIN0_PB4
> 	static int rk_edp_power_ctl(void)
> 	{
> 		int ret;
> 		ret = gpio_request(DVDD33_EN_PIN, "dvdd33_en_pin");
> 		if (ret != 0)
> 		{
> 			gpio_free(DVDD33_EN_PIN);
> 			printk(KERN_ERR "request dvdd33 en pin fail!\n");
> 			return -1;
> 		}
> 		else
> 		{
> 			gpio_direction_output(DVDD33_EN_PIN, DVDD33_EN_VALUE);
> 		}
> 		msleep(5);
> 		
> 		ret = gpio_request(DVDD18_EN_PIN, "dvdd18_en_pin");
> 		if (ret != 0)
> 		{
> 			gpio_free(DVDD18_EN_PIN);
> 			printk(KERN_ERR "request dvdd18 en pin fail!\n");
> 			return -1;
> 		}
> 		else
> 		{
> 			gpio_direction_output(DVDD18_EN_PIN, DVDD18_EN_VALUE);
> 		}
> 		
> 		ret = gpio_request(EDP_RST_PIN, "edp_rst_pin");
> 		if (ret != 0)
> 		{
> 			gpio_free(EDP_RST_PIN);
> 			printk(KERN_ERR "request rst pin fail!\n");
> 			return -1;
> 		}
> 		else
> 		{
> 			gpio_direction_output(EDP_RST_PIN, GPIO_LOW);
> 			msleep(50);
> 			gpio_direction_output(EDP_RST_PIN, GPIO_HIGH);
> 		}
> 		return 0;
> 		
> 	}
> 	static struct anx6345_platform_data anx6345_platform_data = {
> 		.power_ctl 	= rk_edp_power_ctl,
> 		.dvdd33_en_pin 	= DVDD33_EN_PIN,
> 		.dvdd33_en_val 	= DVDD33_EN_VALUE,
> 		.dvdd18_en_pin 	= DVDD18_EN_PIN,
> 		.dvdd18_en_val 	= DVDD18_EN_VALUE,
> 		.edp_rst_pin   	= EDP_RST_PIN,
> 	};
> #endif
> 
870,872c1152
< #ifdef USE_SDMMC_DATA4_DATA7	
<     .emmc_is_selected = NULL,
< #endif
---
> 
967,969c1247
< #ifdef USE_SDMMC_DATA4_DATA7	
< 	.emmc_is_selected = NULL,
< #endif
---
> 
1048a1327
> 
1087,1097c1366,1376
< static u8 config_info_bat0[SIZE_BATINFO] = {
< //金森_DS1006_JSH101_MB7600_ProfileV3LT_20 130712.txt
< 	0x15, 0x54, 0x5D, 0x5A, 0x58,
< 	0x57, 0x52, 0x4E, 0x4C, 0x4A,
< 	0x48, 0x47, 0x42, 0x3D, 0x32,
< 	0x28, 0x21, 0x1A, 0x16, 0x16,
< 	0x1E, 0x34, 0x48, 0x45, 0x3A,
< 	0x43, 0x0B, 0xE7, 0x24, 0x44,
< 	0x45, 0x77, 0x77, 0x6A, 0x67,
< 	0x6B, 0x41, 0x1A, 0x53, 0x3D,
< 	0x04, 0x23, 0x52, 0x87, 0x8F,
---
> static u8 config_info[SIZE_BATINFO] = {
> #if 0
> 	0x15, 0x42, 0x60, 0x59, 0x52,
> 	0x58, 0x4D, 0x48, 0x48, 0x44,
> 	0x44, 0x46, 0x49, 0x48, 0x32,
> 	0x24, 0x20, 0x17, 0x13, 0x0F,
> 	0x19, 0x3E, 0x51, 0x45, 0x08,
> 	0x76, 0x0B, 0x85, 0x0E, 0x1C,
> 	0x2E, 0x3E, 0x4D, 0x52, 0x52,
> 	0x57, 0x3D, 0x1B, 0x6A, 0x2D,
> 	0x25, 0x43, 0x52, 0x87, 0x8F,
1099c1378
< 	0x92, 0x96, 0xB2, 0x80, 0xA2,
---
> 	0x92, 0x96, 0xFF, 0x7B, 0xBB,
1101,1102c1380,1413
< 	0xB5, 0xC1, 0x27, 0x0B
< };
---
> 	0xB5, 0xC1, 0x46, 0xAE
> #else
> /*
> 	0x15, 0x20, 0x5C, 0x5A, 0x58,
> 	0x54, 0x50,	0x4C, 0x49, 0x49,
> 	0x47, 0x45,	0x41, 0x38, 0x2E,
> 	0x26, 0x1D,	0x1A, 0x13, 0x11,
> 	0x1D, 0x3E,	0x4E, 0x4C, 0x36,
> 	0x41, 0x0B, 0x85, 0x1E, 0x3C,
> 	0x43, 0x8B, 0x95, 0x70, 0x61,
> 	0x69, 0x42, 0x1B, 0x52, 0x41,
> 	0x08, 0x22, 0x5F, 0x86, 0x8F,
> 	0x91, 0x91, 0x18, 0x58, 0x82,
> 	0x94, 0xA5, 0x42, 0xB2, 0xDE,
> 	0xCB, 0x2F, 0x7D, 0x72, 0xA5,
> 	0xB5, 0xC1,	0x27, 0x09
> */
> //?e锟斤拷-_DS1006_JSH101_MB7600_ProfileV3LT_20 130705.txt
> /*
> 	0x15, 0x13, 0x59, 0x58, 0x57,
> 	0x55, 0x4F, 0x4C, 0x4A, 0x49,
> 	0x47, 0x45, 0x41, 0x38, 0x2D,
> 	0x26, 0x1E, 0x18, 0x13, 0x12,
> 	0x1D, 0x41, 0x4E, 0x4C, 0x34,
> 	0x50, 0x0A, 0xE1, 0x1B, 0x35,
> 	0x44, 0x89, 0x99, 0x74, 0x62,
> 	0x6A, 0x43, 0x1B, 0x52, 0x4E, 
>     0x0F, 0x22, 0x52, 0x87, 0x8F,
> 	0x91, 0x94, 0x52, 0x82, 0x8C,
> 	0x92, 0x96, 0xB5, 0xB7, 0xE1,
> 	0xCB, 0x2F, 0x7D, 0x72, 0xA5,
> 	0xB5, 0xC1, 0x46, 0xAE
> */
> //2- ?e锟斤拷-_DS1006_JSH101_MB7600_ProfileV3LT_20 130705.txt
1104,1145c1415,1429
< static u8 config_info_bat1[SIZE_BATINFO] = {
< //金森_DS1006_JSH101_MB7600_ProfileV3LT_20 130712.txt
<     0x15, 0x3D, 0x5F, 0x5F, 0x5F, 
<     0x5B, 0x56, 0x52, 0x4D, 0x4B, 
<     0x45, 0x41, 0x3B, 0x32, 0x2D, 
<     0x23, 0x22, 0x23, 0x28, 0x23, 
<     0x25, 0x34, 0x49, 0x6C, 0x87, 
<     0x80, 0x0B, 0x85, 0x0E, 0x1C, 
<     0x29, 0x33, 0x28, 0x26, 0x2B, 
<     0x4A, 0x41, 0x13, 0x36, 0x31, 
<     0x00, 0x19, 0x52, 0x87, 0x8F, 
<     0x91, 0x94, 0x52, 0x82, 0x8C, 
<     0x92, 0x96, 0x80, 0x7E, 0xD1, 
<     0xCB, 0x2F, 0x7D, 0x72, 0xA5, 
<     0xB5, 0xC1, 0x46, 0xAE
< };
< 
< void cw_bat_set_bat_type(struct cw_bat_platform_data *platdata, int type){
<     int i;
<     printk("%s: %d: type=%d\n", __func__, __LINE__, type);
<     
<     switch(type){
<     case 0:
<         platdata->cw_bat_config_info = config_info_bat0;
<         break;
<     case 1:
<         platdata->cw_bat_config_info = config_info_bat1;
<         break;
<     default:
<         platdata->cw_bat_config_info = config_info_bat0;
<         break;
<     }
<     
<     /*printk("%s: %d: config_info_bat0 = 0x%p, config_info_bat1 = 0x%p, cw_bat_config_info = 0x%p\n", __func__, __LINE__, config_info_bat0, config_info_bat1, platdata->cw_bat_config_info);
<     printk("%s: %d: dump cw_bat_config_info:\n", __func__, __LINE__);
<     for(i=0; i<SIZE_BATINFO; i++){
<         if(i!=0 && i%8 == 0)
<             printk("\n"); 
<         printk("0x%02x, ", platdata->cw_bat_config_info[i]);
<     }
<     printk("\n");*/
< }
---
>     0x15, 0x17, 0x5B, 0x58, 0x57,
> 	0x55, 0x4F, 0x4C, 0x4A, 0x49,
> 	0x47, 0x45, 0x41, 0x37, 0x2E,
> 	0x26, 0x1D, 0x19, 0x15, 0x17,
> 	0x20, 0x3C, 0x48, 0x43, 0x35,
> 	0x5A, 0x0A, 0xE1, 0x1C, 0x39,
>     0x44, 0x6D, 0x78, 0x6B, 0x66,
> 	0x6B, 0x42, 0x1B, 0x52, 0x4D,
> 	0x0F, 0x22, 0x52, 0x87, 0x8F,
> 	0x91, 0x94, 0x52, 0x82, 0x8C,
> 	0x92, 0x96, 0x2E, 0x82, 0xA5,
> 	0xCB, 0x2F, 0x7D, 0x72, 0xA5,
>     0xB5, 0xC1, 0x27, 0x0A
> #endif
> };
1149d1432
<     .dc_det_level    = GPIO_LOW,
1150a1434,1435
>     .chg_ok_pin   = RK30_PIN0_PA6,
>     .dc_det_level    = GPIO_LOW,
1152d1436
<     .chg_ok_pin   = INVALID_GPIO,
1154,1158c1438
<     .is_usb_charge = 0,
<     .chg_mode_sel_pin = INVALID_GPIO,
<     .chg_mode_sel_level = GPIO_HIGH,
<     .set_bat_type = cw_bat_set_bat_type,
< //    .cw_bat_config_info     = config_info,
---
>     .cw_bat_config_info     = config_info,
1222c1502
<         .io             = RK30_PIN3_PD1,//INVALID_GPIO, //RK30_PIN3_PC7,
---
>         .io             = RK30_PIN3_PD1,//INVALID_GPIO,
1250c1530,1534
<             .io         = RK30_PIN0_PA5, // set io to INVALID_GPIO for disable it
---
> #if defined (CONFIG_PIPO_M7PRO)
>             .io         = RK30_PIN3_PC7, // set io to INVALID_GPIO to disable it
> #else
>             .io         = RK30_PIN0_PA5, // d33 standard setting
> #endif
1281c1565
< 	printk("%s \n", __FUNCTION__);
---
> /*	printk("%s \n", __FUNCTION__);
1283d1566
< 	rk30_mux_api_set(GPIO1B5_UART3RTSN_NAME, GPIO1B_GPIO1B5);//VCC_EN
1287,1289c1570,1572
< 	rk30_mux_api_set(GPIO1B4_UART3CTSN_GPSRFCLK_NAME, GPIO1B_GPSRFCLK);//GPS_CLK
< 	rk30_mux_api_set(GPIO1B2_UART3SIN_GPSMAG_NAME, GPIO1B_GPSMAG);//GPS_MAG
< 	rk30_mux_api_set(GPIO1B3_UART3SOUT_GPSSIG_NAME, GPIO1B_GPSSIG);//GPS_SIGN
---
> 	iomux_set(GPS_RFCLK);//GPS_CLK
> 	iomux_set(GPS_MAG);//GPS_MAG
> 	iomux_set(GPS_SIG);//GPS_SIGN
1291d1573
< 	rk30_mux_api_set(GPIO1A6_UART1CTSN_SPI0CLK_NAME, GPIO1A_GPIO1A6);//SPI_CLK
1295d1576
< 	rk30_mux_api_set(GPIO1A5_UART1SOUT_SPI0TXD_NAME, GPIO1A_GPIO1A5);//SPI_MOSI
1299d1579
< 	rk30_mux_api_set(GPIO1A7_UART1RTSN_SPI0CSN0_NAME, GPIO1A_GPIO1A7);//SPI_CS
1302a1583,1605
> */
> 		iomux_set(GPIO1_B5);//VCC_EN 
> 		iomux_set(GPIO0_D5);//VCC_EN
> 		iomux_set(GPIO0_D6);//VCC_EN 
> 		iomux_set(GPIO0_D7);//VCC_EN  
> 		gpio_request(RK30_PIN1_PB5, NULL);
> 		gpio_direction_output(RK30_PIN1_PB5, GPIO_LOW);
> 	
> 		iomux_set(GPS_RFCLK);//GPS_CLK
> 		iomux_set(GPS_MAG);//GPS_MAG
> 		iomux_set(GPS_SIG);//GPS_SIGN
> 	
> 		gpio_request(RK30_PIN0_PD6, NULL);//SPI_CLK
> 		gpio_direction_output(RK30_PIN0_PD6, GPIO_LOW);
> 	
> 		gpio_request(RK30_PIN0_PD5, NULL);	 //SPI_MOSI
> 		gpio_direction_output(RK30_PIN0_PD5, GPIO_LOW);
> 	
> 		gpio_request(RK30_PIN0_PD7, NULL);//SPI_CS
> 		gpio_direction_output(RK30_PIN0_PD7, GPIO_LOW); 	
> 		
> 		return 0;
> 
1324,1325c1627,1635
< 	printk("%s \n", __FUNCTION__);
< 	clk_enable(clk_get(NULL, "hclk_gps"));
---
> 	struct clk *gps_aclk = NULL;
> 	gps_aclk = clk_get(NULL, "aclk_gps");
> 	if(gps_aclk) {
> 		clk_enable(gps_aclk);
> 		clk_put(gps_aclk);
> 		printk("%s \n", __FUNCTION__);
> 	}
> 	else
> 		printk("get gps aclk fail\n");
1326a1637
> 
1330,1331c1641,1651
< 	printk("%s \n", __FUNCTION__);
< 	clk_disable(clk_get(NULL, "hclk_gps"));
---
> 	struct clk *gps_aclk = NULL;
> 	gps_aclk = clk_get(NULL, "aclk_gps");
> 	if(gps_aclk) {
> 		//TO wait long enough until GPS ISR is finished.
> 		msleep(5);
> 		clk_disable(gps_aclk);
> 		clk_put(gps_aclk);
> 		printk("%s \n", __FUNCTION__);
> 	}	
> 	else
> 		printk("get gps aclk fail\n");
1345,1347c1665,1667
< 	.GpsSpi_CSO = RK30_PIN1_PA4,    //GPIO index
< 	.GpsSpiClk = RK30_PIN1_PA5,     //GPIO index
< 	.GpsSpiMOSI = RK30_PIN1_PA7,	  //GPIO index
---
> 	.GpsSpi_CSO = RK30_PIN0_PD7,    //RK30_PIN1_PA4 d33 - GPIO index
> 	.GpsSpiClk = RK30_PIN0_PD6,     //RK30_PIN1_PA5 d33 - GPIO index
> 	.GpsSpiMOSI = RK30_PIN0_PD5,	  //RK30_PIN1_PA7 d33 - GPIO index
1349c1669
< 	.GpsSpiEn = 0,
---
> 	.GpsSpiEn = 1, // 0 - d33
1364c1684
< #if defined(CONFIG_MT5931_MT6622)
---
> #if defined(CONFIG_MT5931_MT6622) || defined(CONFIG_MTK_MT6622)
1466c1786
< #ifdef CONFIG_MT5931_MT6622
---
> #if defined(CONFIG_MT5931_MT6622) || defined(CONFIG_MTK_MT6622)
1511a1832,1851
> 
> #if defined(CONFIG_PIPO_M7PRO)
> #if defined (CONFIG_CW2015_BATTERY)
>     {
>         .type           = "cw201x",
>         .addr           = 0x62,
>         .flags          = 0,
>         .platform_data  = &cw_bat_platdata,
>     },
> #endif
> #endif
> 
> #if defined (CONFIG_BATTERY_OZ8806)
> 	{
> 		.type          = "oz8806",
> 		.addr          = 0x2f,
> 		.flags         = 0,
> 	},
> #endif
> 
1624,1625c1964,1965
< 		.min_uv          = 3100000,
< 		.max_uv         = 3100000,
---
> 		.min_uv          = 3300000,
> 		.max_uv         = 3300000,
1627c1967
< 		.suspend_vol  =  3100000,
---
> 		.suspend_vol  =  3300000,
1629c1969
< 		.suspend_vol  =  3100000,
---
> 		.suspend_vol  =  3300000,
1893a2234
> #if !defined(CONFIG_PIPO_M7PRO)
1901a2243
> #endif
1989c2331
< #if defined (CONFIG_CT36X_TS)
---
> #if defined (CONFIG_CT36X_TS) || (CONFIG_TOUCHSCREEN_CT36X)
1997c2339,2340
< #ifdef CONFIG_TOUCHSCREEN_VTL_CT36X
---
> 
> #if defined(CONFIG_HDMI_CAT66121) && (defined(CONFIG_PIPO_M7PRO) || defined(CONFIG_PIPO_M9PRO))
1999,2003c2342,2346
< 		.type        ="vtl_ts",  //设备、驱动名称
< 		.addr        = 0x01,    //设备I2C地址
< 		.flags         = 0,
< 		.irq         =RK30_PIN1_PB7,
< 		.platform_data = &vtl_ts_config_info,
---
> 		.type		= "cat66121_hdmi",
> 		.addr		= 0x4c,
> 		.flags		= 0,
> 		.irq		= RK30_PIN2_PD6,
> 		.platform_data 	= &rk_hdmi_pdata,
2005a2349
> 
2022,2040d2365
< /*#if defined (CONFIG_LS_CM3232)
< 	{
< 		.type          = "light_cm3232", //light_cm3232
< 		.addr          = 0x10,
< 		.flags         = 0,
< 		.platform_data = &cm3232_info,
< 	},
< #endif*/
< 
< #if defined(CONFIG_HDMI_CAT66121)
< 	{
< 		.type		= "cat66121_hdmi",
< 		.addr		= 0x4c,
< 		.flags		= 0,
< 		.irq		= RK30_PIN2_PD6,
< 		.platform_data 	= &rk_hdmi_pdata,
< 	},
< #endif
< 
2060a2386,2394
> #if defined(CONFIG_HDMI_CAT66121) && !(defined(CONFIG_PIPO_M7PRO) || defined(CONFIG_PIPO_M9PRO))
> 	{
> 		.type		= "cat66121_hdmi",
> 		.addr		= 0x4c,
> 		.flags		= 0,
> 		.irq		= RK30_PIN2_PD6,
> 		.platform_data 	= &rk_hdmi_pdata,
> 	},
> #endif
2092a2427,2434
> #if defined (CONFIG_SND_SOC_RT5616)
>         {
>                 .type                   = "rt5616",
>                 .addr                   = 0x1b,
>                 .flags                  = 0,
>         },
> #endif
> 
2187d2528
< 
2189c2530
< 	if (gpio_request(RK30_PIN3_PC7, NULL)) {
---
> /*	if (gpio_request(RK30_PIN3_PC7, NULL)) {
2195c2536,2539
< 
---
> */
>   	gpio_request(RK30_PIN1_PA7, NULL);
> 	gpio_direction_output(RK30_PIN1_PA7, GPIO_HIGH);
> 	
2202,2206d2545
< 	if (gpio_request(RK30_PIN3_PA1, NULL)) {
< 		printk("kevenfunc %s, line %d: request gpio fail\n", __FUNCTION__, __LINE__);
< 	}
< 	gpio_set_value(RK30_PIN3_PA1, GPIO_LOW);//by keven
< 
2215c2554
< #if defined(CONFIG_MT5931_MT6622)
---
> #if defined(CONFIG_MT5931_MT6622) || defined(CONFIG_MTK_MT6622)
2222a2562
> 	int size, ion_reserve_size;
2233c2573,2584
< 	rk30_ion_pdata.heaps[0].base = board_mem_reserve_add("ion", ION_RESERVE_SIZE);
---
> 	size = ddr_get_cap() >> 20;
> 	if(size >= 1024) { // DDR >= 1G, set ion to 120M
> 		rk30_ion_pdata.heaps[0].size = ION_RESERVE_SIZE_120M;
> 		ion_reserve_size = ION_RESERVE_SIZE_120M;
> 	}
> 	else {
> 		rk30_ion_pdata.heaps[0].size = ION_RESERVE_SIZE;
> 		ion_reserve_size = ION_RESERVE_SIZE;
> 	}
> 	printk("ddr size = %d M, set ion_reserve_size size to %d\n", size, ion_reserve_size);
> 	//rk30_ion_pdata.heaps[0].base = board_mem_reserve_add("ion", ION_RESERVE_SIZE);
> 	rk30_ion_pdata.heaps[0].base = board_mem_reserve_add("ion", ion_reserve_size);
2298c2649
<         {.frequency = 1608 * 1000,      .index = 1300 * 1000},
---
>         {.frequency = 1608 * 1000,      .index = 1350 * 1000},
2331,2333c2682,2685
< 	//{.frequency = 400 * 1000 + DDR_FREQ_VIDEO,      .index = 1000 * 1000},
< 	{.frequency = 580 * 1000 + DDR_FREQ_NORMAL,     .index = 1300 * 1000},
< 	//{.frequency = 528 * 1000 + DDR_FREQ_NORMAL,     .index = 1100 * 1000},
---
> 	//{.frequency = 300 * 1000 + DDR_FREQ_VIDEO,      .index = 1000 * 1000},
> 	//{.frequency = 396 * 1000 + DDR_FREQ_NORMAL,     .index = 1100 * 1000},
>     //{.frequency = 460 * 1000 + DDR_FREQ_DUALVIEW,     .index = 1150 * 1000},
> 	{.frequency = 528 * 1000 + DDR_FREQ_NORMAL,     .index = 1250 * 1000},
2336a2689,2693
> static struct cpufreq_frequency_table dvfs_ddr_table_t[] = {
> 	{.frequency = 200 * 1000 + DDR_FREQ_SUSPEND,    .index = 950 * 1000},
> 	{.frequency = 460 * 1000 + DDR_FREQ_NORMAL,     .index = 1150 * 1000},
> 	{.frequency = CPUFREQ_TABLE_END},
> };
2345a2703,2714
> int get_max_freq(struct cpufreq_frequency_table *table)
> {
> 	int i,temp=0;
> 	
> 	for(i=0;table[i].frequency!= CPUFREQ_TABLE_END;i++)
> 	{
> 		if(temp<table[i].frequency)
> 			temp=table[i].frequency;
> 	}	
> 	printk("get_max_freq=%d\n",temp);
> 	return temp;
> }
2349,2350c2718,2728
< 	rk30_clock_data_init(periph_pll_default, codec_pll_default, RK30_CLOCKS_DEFAULT_FLAGS);
< 	//dvfs_set_arm_logic_volt(dvfs_cpu_logic_table, cpu_dvfs_table, dep_cpu2core_table);
---
> 	u32 flags=RK30_CLOCKS_DEFAULT_FLAGS;
> #if !defined(CONFIG_ARCH_RK3188)
> 	if(get_max_freq(dvfs_gpu_table)<=(400*1000))
> 	{	
> 		flags=RK30_CLOCKS_DEFAULT_FLAGS|CLK_GPU_GPLL;
> 	}
> 	else
> 		flags=RK30_CLOCKS_DEFAULT_FLAGS|CLK_GPU_CPLL;
> #endif	
> 	rk30_clock_data_init(periph_pll_default, codec_pll_default, flags);
> 	//dvfs_set_arm_logic_volt(dvfs_cpu_logic_table, cpu_dvfs_table, dep_cpu2core_table);	
2352a2731,2736
> #if defined(CONFIG_ARCH_RK3188)
> 	if (rk_pll_flag() == 0)
> 		dvfs_set_freq_volt_table(clk_get(NULL, "ddr"), dvfs_ddr_table);
> 	else
> 		dvfs_set_freq_volt_table(clk_get(NULL, "ddr"), dvfs_ddr_table_t);
> #else
2353a2738
> #endif
